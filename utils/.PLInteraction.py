import numpy as np
import pandas as pd
from scipy.spatial.distance import cdist
import oddt
import rdkit
from rdkit import Chem
import math
from math import sin, cos
import yaml



BASE_ANGLES = np.array((0, 180, 120, 109.5, 90), dtype=float)
with open("../config/train.yml", "r") as file:
    settings = yaml.safe_load(file)
    


#######################################################################################
################################### Initialisation ####################################
#######################################################################################

"""
Spatial functions included in ODDT
Mainly used by other modules, but can be accessed directly.
"""

def angle(p1, p2, p3):
    """Returns an angle from a series of 3 points (point #2 is centroid).
    Angle is returned in degrees.

    Parameters
    ----------
    p1,p2,p3 : numpy arrays, shape = [n_points, n_dimensions]
        Triplets of points in n-dimensional space, aligned in rows.

    Returns
    -------
    angles : numpy array, shape = [n_points]
        Series of angles in degrees
    """
    v1 = p1 - p2
    v2 = p3 - p2
    return angle_2v(v1, v2)


def angle_2v(v1, v2):
    """Returns an angle between two vecors.Angle is returned in degrees.

    Parameters
    ----------
    v1,v2 : numpy arrays, shape = [n_vectors, n_dimensions]
        Pairs of vectors in n-dimensional space, aligned in rows.

    Returns
    -------
    angles : numpy array, shape = [n_vectors]
        Series of angles in degrees
    """
    # better than np.dot(v1, v2), multiple vectors can be applied
    dot = (v1 * v2).sum(axis=-1)
    norm = np.linalg.norm(v1, axis=-1) * np.linalg.norm(v2, axis=-1)
    return np.degrees(np.arccos(np.clip(dot/norm, -1, 1)))


def distance(x, y):
    """Computes distance between each pair of points from x and y.

    Parameters
    ----------
    x : numpy arrays, shape = [n_x, 3]
        Array of poinds in 3D

    y : numpy arrays, shape = [n_y, 3]
        Array of poinds in 3D

    Returns
    -------
    dist_matrix : numpy arrays, shape = [n_x, n_y]
        Distance matrix
    """
    return cdist(x, y)
    

def close_contacts(x, y, cutoff, x_column='coords', y_column='coords', cutoff_low=0.):
    """Returns pairs of atoms which are within close contac distance cutoff.
    The cutoff is semi-inclusive, i.e (cutoff_low, cutoff].

    Parameters
    ----------
    x, y : atom_dict-type numpy array
        Atom dictionaries generated by oddt.toolkit.Molecule objects.

    cutoff : float
        Cutoff distance for close contacts

    x_column, ycolumn : string, (default='coords')
        Column containing coordinates of atoms (or pseudo-atoms,
        i.e. ring centroids)

    cutoff_low : float (default=0.)
        Lower bound of contacts to find (exclusive). Zero by default.
        .. versionadded:: 0.6

    Returns
    -------
    x_, y_ : atom_dict-type numpy array
        Aligned pairs of atoms in close contact for further processing.
    """
    if len(x[x_column]) > 0 and len(x[x_column]) > 0:
        d = distance(x[x_column], y[y_column])
        index = np.argwhere((d > cutoff_low) & (d <= cutoff))
        return x[index[:, 0]], y[index[:, 1]]
    else:
        return x[[]], y[[]]


def _check_angles(angles, hybridizations, tolerance):
    """Helper function for checking if interactions are strict"""
    angles = np.nan_to_num(angles)  # NaN's throw warning on comparisons
    ideal_angles = np.take(BASE_ANGLES, hybridizations)[:, np.newaxis]
    lower_bound = ideal_angles - tolerance
    upper_bound = ideal_angles + tolerance
    return ((angles > lower_bound) & (angles < upper_bound)).any(axis=-1)


def hbond_acceptor_donor(mol1, mol2, cutoff=3.5, tolerance=30, donor_exact=False):
    """Returns pairs of acceptor-donor atoms, which meet H-bond criteria

    Parameters
    ----------
    mol1, mol2 : oddt.toolkit.Molecule object
        Molecules to compute H-bond acceptor and H-bond donor pairs

    cutoff : float, (default=3.5)
        Distance cutoff for A-D pairs

    tolerance : int, (default=30)
        Range (+/- tolerance) from perfect direction defined by acceptor/donor hybridization
        in which H-bonds are considered as strict.
    donor_exact : bool
        Use exact protonation states for donors, i.e. require Hs on donor.
        By default ODDT implies some tautomeric structures as protonated,
        even if there is no H on specific atom.

    Returns
    -------
    a, d : atom_dict-type numpy array
        Aligned arrays of atoms forming H-bond, firstly acceptors,
        secondly donors.

    strict : numpy array, dtype=bool
        Boolean array align with atom pairs, informing whether atoms
        form 'strict' H-bond (pass all angular cutoffs). If false,
        only distance cutoff is met, therefore the bond is 'crude'.
    """
    donor_mask = mol2.atom_dict['isdonor']
    if donor_exact:
        donor_mask = donor_mask & (mol2.atom_dict['numhs'] > 0)
    a, d = close_contacts(mol1.atom_dict[mol1.atom_dict['isacceptor']],
                          mol2.atom_dict[donor_mask],
                          cutoff)
    # skip empty values
    if len(a) > 0 and len(d) > 0:
        angle1 = angle(d['coords'][:, np.newaxis, :],
                       a['coords'][:, np.newaxis, :],
                       a['neighbors'])
        angle2 = angle(a['coords'][:, np.newaxis, :],
                       d['coords'][:, np.newaxis, :],
                       d['neighbors'])
        strict = (_check_angles(angle1, a['hybridization'], tolerance) &
                  _check_angles(angle2, d['hybridization'], tolerance))
        return a, d, angle1, angle2, strict
    else:
        return a, d, np.array([], dtype=bool), np.array([], dtype=bool), np.array([], dtype=bool)

def halogenbond_acceptor_halogen(mol1,
                                 mol2,
                                 tolerance=30,
                                 cutoff=4):
    """Returns pairs of acceptor-halogen atoms, which meet halogen bond criteria

    Parameters
    ----------
    mol1, mol2 : oddt.toolkit.Molecule object
        Molecules to compute halogen bond acceptor and halogen pairs

    cutoff : float, (default=4)
        Distance cutoff for A-H pairs

    tolerance : int, (default=30)
        Range (+/- tolerance) from perfect direction defined by atoms hybridization
        in which halogen bonds are considered as strict.

    Returns
    -------
    a, h : atom_dict-type numpy array
        Aligned arrays of atoms forming halogen bond, firstly acceptors,
        secondly halogens

    strict : numpy array, dtype=bool
        Boolean array align with atom pairs, informing whether atoms
        form 'strict' halogen bond (pass all angular cutoffs). If false,
        only distance cutoff is met, therefore the bond is 'crude'.
    """
    a, h = close_contacts(mol1.atom_dict[mol1.atom_dict['isacceptor']],
                          mol2.atom_dict[mol2.atom_dict['ishalogen']],
                          cutoff)
    # skip empty values
    if len(a) > 0 and len(h) > 0:
        angle1 = angle(h['coords'][:, np.newaxis, :],
                       a['coords'][:, np.newaxis, :],
                       a['neighbors'])
        angle2 = angle(a['coords'][:, np.newaxis, :],
                       h['coords'][:, np.newaxis, :],
                       h['neighbors'])
        strict = (_check_angles(angle1, a['hybridization'], tolerance) &
                  _check_angles(angle2, np.ones_like(h['hybridization']), tolerance))
        return a, h, angle1, angle2, strict
    else:
        return a, h, np.array([], dtype=bool), np.array([], dtype=bool), np.array([], dtype=bool)


def salt_bridge_plus_minus(mol1, mol2, cutoff=4, cation_exact=False, anion_exact=False):
    """Returns pairs of plus-mins atoms, which meet salt bridge criteria

    Parameters
    ----------
    mol1, mol2 : oddt.toolkit.Molecule object
        Molecules to compute plus and minus pairs

    cutoff : float, (default=4)
        Distance cutoff for A-H pairs

    cation_exact, anion_exact : bool
        Requires interacting atoms to have non-zero formal charge.

    Returns
    -------
    plus, minus : atom_dict-type numpy array
        Aligned arrays of atoms forming salt bridge, firstly plus, secondly minus

    """
    cation_map = mol1.atom_dict['isplus']
    if cation_exact:
        cation_map = cation_map & (mol1.atom_dict['formalcharge'] > 0)
    anion_map = mol2.atom_dict['isminus']
    if anion_exact:
        anion_map = anion_map & (mol2.atom_dict['formalcharge'] < 0)
    m1_plus, m2_minus = close_contacts(mol1.atom_dict[cation_map],
                                       mol2.atom_dict[anion_map],
                                       cutoff)
    return m1_plus, m2_minus


def calculate_atomic_rmsd(reference_mol, target_mol):
    reference_atoms = reference_mol.GetAtoms()
    target_atoms = target_mol.GetAtoms()

    if len(reference_atoms) != len(target_atoms):
        raise ValueError("The number of atoms in the molecules does not match.")

    squared_sum = 0.0
    count = 0

    for ref_atom, tgt_atom in zip(reference_atoms, target_atoms):
        ref_coords = ref_atom.GetPosition()
        tgt_coords = tgt_atom.GetPosition()

        squared_sum += (ref_coords.x - tgt_coords.x) ** 2
        squared_sum += (ref_coords.y - tgt_coords.y) ** 2
        squared_sum += (ref_coords.z - tgt_coords.z) ** 2
        count += 3

    rmsd = (squared_sum / count) ** 0.5

    return rmsd


#######################################################################################
##################################### Extraction ######################################
#######################################################################################

def hbonds_oddt(protein, ligand, fp, fl, _int=True, cutoff=settings['hbond_dist_cut'], tolerance=30, mol1_exact=False, mol2_exact=False):
    """
    a1, d2 : protein as acceptor, ligand as donor
    """
    a1, d2, angle1, angle2, strict = hbond_acceptor_donor(protein, ligand, cutoff, tolerance, mol2_exact)
    """
    angle1 = angle(a1d2[1]['coords'][:, np.newaxis, :],
                   a1d2[0]['coords'][:, np.newaxis, :],
                   a1d2[0]['neighbors'])
    angle2 = angle(a1d2[0]['coords'][:, np.newaxis, :],
                   a1d2[1]['coords'][:, np.newaxis, :],
                   a1d2[1]['neighbors'])
    """
    
    for i in range(len(a1)):
        _dist = math.dist(a1['coords'][i], d2['coords'][i])
        a_charge, d_charge = a1['charge'][i], d2['charge'][i]
        a_resname, d_resname = a1['resname'][i], d2['resname'][i]
        a_atom, d_atom = a1['atomicnum'][i], d2['atomicnum'][i]
        a_is_aromatic, d_is_aromatic = a1['isaromatic'][i], d2['isaromatic'][i]
        a_is_acceptor, d_is_acceptor = a1['isacceptor'][i], d2['isacceptor'][i]
        a_is_donor, d_is_donor = a1['isdonor'][i], d2['isdonor'][i]
        a_neighbors, d_neighbors = a1['neighbors_id'][i], d2['neighbors_id'][i]
        a_num_neighbors, d_num_neighbors = np.count_nonzero(a_neighbors), np.count_nonzero(d_neighbors)
        
        if _int == True:
            if a_resname == '':
                a_resname = 'LIG'
            elif d_resname == '':
              d_resname = 'LIG'
        
        fp.loc[int(a1['id'][i]), 'is_hbond'],            fl.loc[int(d2['id'][i]), 'is_hbond']            = True, True
        fp.loc[int(a1['id'][i]), 'hbond_partner'],       fl.loc[int(d2['id'][i]), 'hbond_partner']       = int(d2['id'][i]), int(a1['id'][i])
        fp.loc[int(a1['id'][i]), 'hbond_dist'],          fl.loc[int(d2['id'][i]), 'hbond_dist']          = float(_dist), float(_dist)
        fp.loc[int(a1['id'][i]), 'hbond_angle'],         fl.loc[int(d2['id'][i]), 'hbond_angle']         = float(angle2[i][0]), float(angle2[i][0])
        fp.loc[int(a1['id'][i]), 'hbond_charge'],        fl.loc[int(d2['id'][i]), 'hbond_charge']        = float(a_charge), float(d_charge)
        fp.loc[int(a1['id'][i]), 'hbond_num_neighbors'], fl.loc[int(d2['id'][i]), 'hbond_num_neighbors'] = int(a_num_neighbors), int(d_num_neighbors)
        fp.loc[int(a1['id'][i]), 'hbond_atomicnum'],     fl.loc[int(d2['id'][i]), 'hbond_atomicnum']     = int(a_atom), int(d_atom)
        fp.loc[int(a1['id'][i]), 'hbond_resname'],       fl.loc[int(d2['id'][i]), 'hbond_resname']       = str(a_resname), str(d_resname)
        fp.loc[int(a1['id'][i]), 'hbond_is_aromatic'],   fl.loc[int(d2['id'][i]), 'hbond_is_aromatic']   = a_is_aromatic, d_is_aromatic
        fp.loc[int(a1['id'][i]), 'hbond_is_acceptor'],   fl.loc[int(d2['id'][i]), 'hbond_is_acceptor']   = True, False
        fp.loc[int(a1['id'][i]), 'hbond_is_donor'],      fl.loc[int(d2['id'][i]), 'hbond_is_donor']      = False, True
    
    """    
    a2, d1 : protein as donor, ligand as acceptor
    """ 
    a2, d1, angle1, angle2, strict = hbond_acceptor_donor(ligand, protein, cutoff, tolerance, mol1_exact)
    """
    angle1 = angle(a2d1[1]['coords'][:, np.newaxis, :],
                   a2d1[0]['coords'][:, np.newaxis, :],
                   a2d1[0]['neighbors'])
    angle2 = angle(a2d1[0]['coords'][:, np.newaxis, :],
                   a2d1[1]['coords'][:, np.newaxis, :],
                   a2d1[1]['neighbors'])
    """
        
    for i in range(len(a2)):
        _dist = math.dist(a2['coords'][i], d1['coords'][i])
        a_charge, d_charge = a2['charge'][i], d1['charge'][i]
        a_resname, d_resname = a2['resname'][i], d1['resname'][i]
        a_atom, d_atom = a2['atomicnum'][i], d1['atomicnum'][i]
        a_is_aromatic, d_is_aromatic = a2['isaromatic'][i], d1['isaromatic'][i]
        a_is_acceptor, d_is_acceptor = a2['isacceptor'][i], d1['isacceptor'][i]
        a_is_donor, d_is_donor = a2['isdonor'][i], d1['isdonor'][i]
        a_neighbors, d_neighbors = a2['neighbors_id'][i], d1['neighbors_id'][i]
        a_num_neighbors, d_num_neighbors = np.count_nonzero(a_neighbors), np.count_nonzero(d_neighbors)
        
        if _int == True:
            if a_resname == '':
                a_resname = 'LIG'
            elif d_resname == '':
                d_resname = 'LIG'
        else:
            pass

        fl.loc[int(a2['id'][i]), 'is_hbond'],            fp.loc[int(d1['id'][i]), 'is_hbond']            = True, True
        fl.loc[int(a2['id'][i]), 'hbond_partner'],       fp.loc[int(d1['id'][i]), 'hbond_partner']       = int(d1['id'][i]), int(a2['id'][i])
        fl.loc[int(a2['id'][i]), 'hbond_dist'],          fp.loc[int(d1['id'][i]), 'hbond_dist']          = float(_dist), float(_dist)
        fl.loc[int(a2['id'][i]), 'hbond_angle'],         fp.loc[int(d1['id'][i]), 'hbond_angle']         = float(angle2[i][0]), float(angle2[i][0])
        fl.loc[int(a2['id'][i]), 'hbond_charge'],        fp.loc[int(d1['id'][i]), 'hbond_charge']        = float(a_charge), float(d_charge)
        fl.loc[int(a2['id'][i]), 'hbond_num_neighbors'], fp.loc[int(d1['id'][i]), 'hbond_num_neighbors'] = int(a_num_neighbors), int(d_num_neighbors)
        fl.loc[int(a2['id'][i]), 'hbond_atomicnum'],     fp.loc[int(d1['id'][i]), 'hbond_atomicnum']     = int(a_atom), int(d_atom)
        fl.loc[int(a2['id'][i]), 'hbond_resname'],       fp.loc[int(d1['id'][i]), 'hbond_resname']       = str(a_resname), str(d_resname)
        fl.loc[int(a2['id'][i]), 'hbond_is_aromatic'],   fp.loc[int(d1['id'][i]), 'hbond_is_aromatic']   = a_is_aromatic, d_is_aromatic
        fl.loc[int(a2['id'][i]), 'hbond_is_acceptor'],   fp.loc[int(d1['id'][i]), 'hbond_is_acceptor']   = True, False
        fl.loc[int(a2['id'][i]), 'hbond_is_donor'],      fp.loc[int(d1['id'][i]), 'hbond_is_donor']      = False, True

    return fp, fl


def xbonds_oddt(protein, ligand, fp, fl, _int=True, cutoff=settings['xbond_dist_cut'], tolerance=30, mol1_exact=False, mol2_exact=False):
    """
    a1, h2 : protein as acceptor, ligand as halogen donor
    """
    a1, h2, angle1, angle2, strict = halogenbond_acceptor_halogen(protein, ligand, cutoff, tolerance)
    """
    angle1 = angle(a1h2[1]['coords'][:, np.newaxis, :],
                   a1h2[0]['coords'][:, np.newaxis, :],
                   a1h2[0]['neighbors'])
    angle2 = angle(a1h2[0]['coords'][:, np.newaxis, :],
                   a1h2[1]['coords'][:, np.newaxis, :],
                   a1h2[1]['neighbors'])
    """
    
    for i in range(len(a1)):
        _dist = math.dist(a1['coords'][i], h2['coords'][i])
        a_charge, h_charge = a1['charge'][i], h2['charge'][i]
        a_resname, h_resname = a1['resname'][i], h2['resname'][i]
        a_atom, h_atom = a1['atomicnum'][i], h2['atomicnum'][i]
        a_is_aromatic, h_is_aromatic = a1['isaromatic'][i], h2['isaromatic'][i]
        a_is_acceptor, h_is_acceptor = a1['isacceptor'][i], h2['isacceptor'][i]
        a_is_donor, h_is_donor = a1['isdonor'][i], h2['isdonor'][i]
        a_neighbors, h_neighbors = a1['neighbors_id'][i], h2['neighbors_id'][i]
        a_num_neighbors, h_num_neighbors = np.count_nonzero(a_neighbors), np.count_nonzero(h_neighbors)
        
        if _int == True:
            if a_resname == '':
                a_resname = 'LIG'
            elif h_resname == '':
              h_resname = 'LIG'
        else:
            pass

        fp.loc[int(a1['id'][i]), 'is_xbond'],            fl.loc[int(h2['id'][i]), 'is_hbond']            = True, True
        fp.loc[int(a1['id'][i]), 'xbond_partner'],       fl.loc[int(h2['id'][i]), 'xbond_partner']       = int(h2['id'][i]), int(a1['id'][i])
        fp.loc[int(a1['id'][i]), 'xbond_dist'],          fl.loc[int(h2['id'][i]), 'xbond_dist']          = float(_dist), float(_dist)
        fp.loc[int(a1['id'][i]), 'xbond_angle'],         fl.loc[int(h2['id'][i]), 'xbond_angle']         = float(angle2[i][0]), float(angle2[i][0])
        fp.loc[int(a1['id'][i]), 'xbond_charge'],        fl.loc[int(h2['id'][i]), 'xbond_charge']        = float(a_charge), float(h_charge)
        fp.loc[int(a1['id'][i]), 'xbond_num_neighbors'], fl.loc[int(h2['id'][i]), 'xbond_num_neighbors'] = int(a_num_neighbors), int(h_num_neighbors)
        fp.loc[int(a1['id'][i]), 'xbond_atomicnum'],     fl.loc[int(h2['id'][i]), 'xbond_atomicnum']     = int(a_atom), int(h_atom)
        fp.loc[int(a1['id'][i]), 'xbond_resname'],       fl.loc[int(h2['id'][i]), 'xbond_resname']       = str(a_resname), str(h_resname)
        fp.loc[int(a1['id'][i]), 'xbond_is_aromatic'],   fl.loc[int(h2['id'][i]), 'xbond_is_aromatic']   = a_is_aromatic, h_is_aromatic
        fp.loc[int(a1['id'][i]), 'xbond_is_acceptor'],   fl.loc[int(h2['id'][i]), 'xbond_is_acceptor']   = True, False
        fp.loc[int(a1['id'][i]), 'xbond_is_donor'],      fl.loc[int(h2['id'][i]), 'xbond_is_donor']      = False, True
        
    """    
    a2h1 : protein as donor, ligand as halogen acceptor
    """ 
    a2, h1, angle1, angle2, strict = halogenbond_acceptor_halogen(ligand, protein, cutoff, tolerance)
    """
    angle1 = angle(a2h1[1]['coords'][:, np.newaxis, :],
                   a2h1[0]['coords'][:, np.newaxis, :],
                   a2h1[0]['neighbors'])
    angle2 = angle(a2h1[0]['coords'][:, np.newaxis, :],
                   a2h1[1]['coords'][:, np.newaxis, :],
                   a2h1[1]['neighbors'])
    """
    for i in range(len(a2)):
        _dist = math.dist(a2['coords'][i], h1['coords'][i])
        a_charge, h_charge = a2['charge'][i], h1['charge'][i]
        a_resname, h_resname = a2['resname'][i], h1['resname'][i]
        a_atom, h_atom = a2['atomicnum'][i], h1['atomicnum'][i]
        a_is_aromatic, h_is_aromatic = a2['isaromatic'][i], h1['isaromatic'][i]
        a_is_acceptor, h_is_acceptor = a2['isacceptor'][i], h1['isacceptor'][i]
        a_is_donor, h_is_donor = a2['isdonor'][i], h1['isdonor'][i]
        a_neighbors, h_neighbors = a2['neighbors_id'][i], h1['neighbors_id'][i]
        a_num_neighbors, h_num_neighbors = np.count_nonzero(a_neighbors), np.count_nonzero(h_neighbors)
        
        if _int == True:
            if a_resname == '':
                a_resname = 'LIG'
            elif h_resname == '':
                h_resname = 'LIG'
        else:
            pass

        fl.loc[int(a2['id'][i]), 'is_xbond'],            fp.loc[int(h1['id'][i]), 'is_xbond']            = True, True
        fl.loc[int(a2['id'][i]), 'xbond_partner'],       fp.loc[int(h1['id'][i]), 'xbond_partner']       = int(h1['id'][i]), int(a2['id'][i])
        fl.loc[int(a2['id'][i]), 'xbond_dist'],          fp.loc[int(h1['id'][i]), 'xbond_dist']          = float(_dist), float(_dist)
        fl.loc[int(a2['id'][i]), 'xbond_angle'],         fp.loc[int(h1['id'][i]), 'xbond_angle']         = float(angle2[i][0]), float(angle2[i][0])
        fl.loc[int(a2['id'][i]), 'xbond_charge'],        fp.loc[int(h1['id'][i]), 'xbond_charge']        = float(a_charge), float(h_charge)
        fl.loc[int(a2['id'][i]), 'xbond_num_neighbors'], fp.loc[int(h1['id'][i]), 'xbond_num_neighbors'] = int(a_num_neighbors), int(h_num_neighbors)
        fl.loc[int(a2['id'][i]), 'xbond_atomicnum'],     fp.loc[int(h1['id'][i]), 'xbond_atomicnum']     = int(a_atom), int(h_atom)
        fl.loc[int(a2['id'][i]), 'xbond_resname'],       fp.loc[int(h1['id'][i]), 'xbond_resname']       = str(a_resname), str(h_resname)
        fl.loc[int(a2['id'][i]), 'xbond_is_aromatic'],   fp.loc[int(h1['id'][i]), 'xbond_is_aromatic']   = a_is_aromatic, h_is_aromatic
        fl.loc[int(a2['id'][i]), 'xbond_is_acceptor'],   fp.loc[int(h1['id'][i]), 'xbond_is_acceptor']   = True, False
        fl.loc[int(a2['id'][i]), 'xbond_is_donor'],      fp.loc[int(h1['id'][i]), 'xbond_is_donor']      = False, True
    
    return fp, fl


def hphob_oddt(protein, ligand, fp, fl, cutoff=settings['hphob_dist_cut'], _int=True):
    h1, h2 = close_contacts(protein.atom_dict[protein.atom_dict['ishydrophobe']], 
                            ligand.atom_dict[ligand.atom_dict['ishydrophobe']], 
                            cutoff)

    for i in range(len(h1)):
        _dist = math.dist(h1['coords'][i], h2['coords'][i])
        _charge_h1, _charge_h2 = h1['charge'][i], h2['charge'][i]
        _resname_h1, _resname_h2 = h1['resname'][i], h2['resname'][i]
        _atom_h1, _atom_h2 = h1['atomicnum'][i], h2['atomicnum'][i]
        _neighbors_h1, _neighbors_h2 = h1['neighbors_id'][i], h2['neighbors_id'][i]
        _num_neighbors_h1, _num_neighbors_h2 = np.count_nonzero(_neighbors_h1), np.count_nonzero(_neighbors_h2)
        _is_aromatic_h1, _is_aromatic_h2 = h1['isaromatic'][i], h2['isaromatic'][i]
        
        if _int == True:
            if _resname_h1 == '':
                _resname_h1 = 'LIG'
            elif _resname_h2 == '':
                _resname_h2 = 'LIG'
        
        fp.loc[int(h1['id'][i]), 'is_hphob'],            fl.loc[int(h2['id'][i]), 'is_hphob']            = True, True
        fp.loc[int(h1['id'][i]), 'hphob_partner'],       fl.loc[int(h2['id'][i]), 'hphob_partner']       = int(h1['id'][i]), int(h2['id'][i])
        fp.loc[int(h1['id'][i]), 'hphob_dist'],          fl.loc[int(h2['id'][i]), 'hphob_dist']          = float(_dist), float(_dist)
        fp.loc[int(h1['id'][i]), 'hphob_charge'],        fl.loc[int(h2['id'][i]), 'hphob_charge']        = float(_charge_h1), float(_charge_h2)
        fp.loc[int(h1['id'][i]), 'hphob_atomicnum'],     fl.loc[int(h2['id'][i]), 'hphob_atomicnum']     = int(_atom_h1), int(_atom_h2)
        fp.loc[int(h1['id'][i]), 'hphob_resname'],       fl.loc[int(h2['id'][i]), 'hphob_resname']       = str(_resname_h1), str(_resname_h2)
        fp.loc[int(h1['id'][i]), 'hphob_num_neighbors'], fl.loc[int(h2['id'][i]), 'hphob_num_neighbors'] = int(_num_neighbors_h1), int(_num_neighbors_h2)
        fp.loc[int(h1['id'][i]), 'hphob_is_aromatic'],   fl.loc[int(h2['id'][i]), 'hphob_is_aromatic']   = _is_aromatic_h1, _is_aromatic_h2

    return fp, fl
    
    
def sbridge_oddt(protein, ligand, fp, fl, _int=True, cutoff=settings['sbridge_dist_cut'], mol1_exact=True, mol2_exact=True):
    p1, l2 = salt_bridge_plus_minus(protein, ligand, cutoff)
    l1, p2 = salt_bridge_plus_minus(ligand, protein, cutoff)

    """
    p1, l2: protein positive, ligand negative
    """
    for i in range(len(p1)):
        _dist = math.dist(p1['coords'][i], l2['coords'][i])
        c_charge, a_charge = p1['charge'][i], l2['charge'][i]
        c_resname, a_resname = p1['resname'][i], l2['resname'][i]
        c_atom, a_atom = p1['atomicnum'][i], l2['atomicnum'][i]
        c_neighbors, a_neighbors = p1['neighbors_id'][i], l2['neighbors_id'][i]
        c_num_neighbors, a_num_neighbors = np.count_nonzero(c_neighbors), np.count_nonzero(a_neighbors)
        c_is_aromatic, a_is_aromatic = p1['isaromatic'][i], l2['isaromatic'][i]
                        
        if _int == True:
            if a_resname == '':
                a_resname = 'LIG'
            elif c_resname == '':
              c_resname = 'LIG'
        else:
            pass
            
        fp.loc[int(p1['id'][i]), 'is_sbridge'],            fl.loc[int(l2['id'][i]), 'is_sbridge']            = True, True
        fp.loc[int(p1['id'][i]), 'sbridge_partner'],       fl.loc[int(l2['id'][i]), 'sbridge_partner']       = int(l2['id'][i]), int(p1['id'][i])
        fp.loc[int(p1['id'][i]), 'sbridge_dist'],          fl.loc[int(l2['id'][i]), 'sbridge_dist']          = float(_dist), float(_dist)
        fp.loc[int(p1['id'][i]), 'sbridge_charge'],        fl.loc[int(l2['id'][i]), 'sbridge_charge']        = float(c_charge), float(a_charge)
        fp.loc[int(p1['id'][i]), 'sbridge_atomicnum'],     fl.loc[int(l2['id'][i]), 'sbridge_atomicnum']     = int(c_atom), int(a_atom)
        fp.loc[int(p1['id'][i]), 'sbridge_resname'],       fl.loc[int(l2['id'][i]), 'sbridge_resname']       = str(c_resname), str(a_resname)
        fp.loc[int(p1['id'][i]), 'sbridge_num_neighbors'], fl.loc[int(l2['id'][i]), 'sbridge_num_neighbors'] = int(c_num_neighbors), int(a_num_neighbors)
        fp.loc[int(p1['id'][i]), 'sbridge_is_aromatic'],   fl.loc[int(l2['id'][i]), 'sbridge_is_aromatic']   = c_is_aromatic, a_is_aromatic
        fp.loc[int(p1['id'][i]), 'sbridge_is_pos'],        fl.loc[int(l2['id'][i]), 'sbridge_is_neg']        = True, False
    
    """
    l1, p2: ligand positive, protein negative
    """
    for i in range(len(l1)):
        _dist = math.dist(l1['coords'][i], p2['coords'][i])
        c_charge, a_charge = l1['charge'][i], p2['charge'][i]
        c_resname, a_resname = l1['resname'][i], p2['resname'][i]
        c_atom, a_atom = l1['atomicnum'][i], p2['atomicnum'][i]
        c_neighbors, a_neighbors = l1['neighbors_id'][i], p2['neighbors_id'][i]
        c_num_neighbors, a_num_neighbors = np.count_nonzero(c_neighbors), np.count_nonzero(a_neighbors)
        c_is_aromatic, a_is_aromatic = l1['isaromatic'][i], p2['isaromatic'][i]
                        
        if _int == True:
            if a_resname == '':
                a_resname = 'LIG'
            elif c_resname == '':
              c_resname = 'LIG'
        else:
            pass
            
        fp.loc[int(p2['id'][i]), 'is_sbridge'],            fl.loc[int(l1['id'][i]), 'is_sbridge']            = True, True
        fp.loc[int(p2['id'][i]), 'sbridge_partner'],       fl.loc[int(l1['id'][i]), 'sbridge_partner']       = int(l1['id'][i]), int(p2['id'][i])
        fp.loc[int(p2['id'][i]), 'sbridge_dist'],          fl.loc[int(l1['id'][i]), 'sbridge_dist']          = float(_dist), float(_dist)
        fp.loc[int(p2['id'][i]), 'sbridge_charge'],        fl.loc[int(l1['id'][i]), 'sbridge_charge']        = float(a_charge), float(c_charge)
        fp.loc[int(p2['id'][i]), 'sbridge_atomicnum'],     fl.loc[int(l1['id'][i]), 'sbridge_atomicnum']     = int(a_atom), int(c_atom)
        fp.loc[int(p2['id'][i]), 'sbridge_resname'],       fl.loc[int(l1['id'][i]), 'sbridge_resname']       = str(a_resname), str(c_resname)
        fp.loc[int(p2['id'][i]), 'sbridge_num_neighbors'], fl.loc[int(l1['id'][i]), 'sbridge_num_neighbors'] = int(a_num_neighbors), int(c_num_neighbors)
        fp.loc[int(p2['id'][i]), 'sbridge_is_aromatic'],   fl.loc[int(l1['id'][i]), 'sbridge_is_aromatic']   = a_is_aromatic, c_is_aromatic
        fp.loc[int(p2['id'][i]), 'sbridge_is_pos'],        fl.loc[int(l1['id'][i]), 'sbridge_is_neg']        = False, True

    return fp, fl
    

def pistack_oddt(protein, ligand, fp, fl, _int=True, cutoff=settings['pistack_dist_cut'], tolerance=30):
    r1, r2 = close_contacts(protein.ring_dict, ligand.ring_dict, cutoff, x_column='centroid', y_column='centroid')
    
    angle1 = angle_2v(r1['vector'], r2['vector'])
    angle2 = angle(r1['vector'] + r1['centroid'],
                   r1['centroid'],
                   r2['centroid'])
    angle3 = angle(r2['vector'] + r2['centroid'],
                   r2['centroid'],
                   r1['centroid'])

    for i in range(len(r1)):
        _dist = math.dist(r1['centroid'][i], r2['centroid'][i])
        _resname_r1, _resname_r2 = r1['resname'][i], r2['resname'][i]
        _resnum_r1, _resnum_r2 = r1['resnum'][i], r2['resnum'][i]

        if _int == True:
            if _resname_r1 == '':
                _resname_r1 = 'LIG'
            elif _resname_r2 == '':
                _resname_r2 = 'LIG'
            
        _atoms_array_r1 = np.where(protein.atom_dict['resnum'] == _resnum_r1)[0]
        _atoms_array_r2 = np.where(ligand.atom_dict['resnum'] == _resnum_r2)[0]
        
        for j in range(len(_atoms_array_r1)):
            idx = int(_atoms_array_r1[j])
            
            for k in range(len(_atoms_array_r2)):
                idy = int(_atoms_array_r2[k])
        
                fp.loc[idx, 'is_pistack'],            fl.loc[idy, 'is_pistack']            = True, True
                fp.loc[idx, 'pistack_partner'],       fl.loc[idy, 'pistack_partner']       = idy, idx
                fp.loc[idx, 'pistack_dist'],          fl.loc[idy, 'pistack_dist']          = float(_dist), float(_dist)
                fp.loc[idx, 'pistack_angle'],         fl.loc[idy, 'pistack_angle']         = float(angle1[i]), float(angle1[i])
                fp.loc[idx, 'pistack_resname'],       fl.loc[idy, 'pistack_resname']       = str(_resname_r1), str(_resname_r2)
                fp.loc[idx, 'pistack_atomicnum'],     fl.loc[idy, 'pistack_atomicnum']     = int(protein.atom_dict[idx]['atomicnum']), int(ligand.atom_dict[idy]['atomicnum'])
                fp.loc[idx, 'pistack_num_neighbors'], fl.loc[idy, 'pistack_num_neighbors'] = int(np.count_nonzero(protein.atom_dict[idx]['neighbors_id'])), int(np.count_nonzero(ligand.atom_dict[idy]['neighbors_id']))

    return fp, fl


def pication_oddt(protein, ligand, fp, fl, _int=True, cutoff=settings['pication_dist_cut'], tolerance=30, cation_exact=False):
    cation_map = ligand.atom_dict['isplus']
    r1, plus2 = close_contacts(protein.ring_dict, ligand.atom_dict[cation_map], cutoff, x_column='centroid')
    angle1 = angle_2v(r1['vector'], plus2['coords'] - r1['centroid'])

    for i in range(len(r1)):
        _dist = math.dist(r1['centroid'][i], plus2['coords'][i])
        _resname_r1, _resname_plus2 = r1['resname'][i], plus2['resname'][i]
        _resnum_r1, _resnum_plus2 = r1['resnum'][i], plus2['resnum'][i]
        _atom_plus2 = plus2['atomicnum'][i]
        _neighbors_plus2 = plus2['neighbors_id'][i]
        _num_neighbors_plus2 = np.count_nonzero(_neighbors_plus2)

        if _int == True:
            if _resname_r1 == '':
                _resname_r1 = 'LIG'
            elif _resname_plus2 == '':
                _resname_plus2 = 'LIG'

        
        _atoms_array = np.where(protein.atom_dict['resnum'] == _resnum_r1)[0]
        for j in range(len(_atoms_array)):
            idx = int(_atoms_array[j])
            
            fp.loc[idx, 'is_picat'],            fl.loc[int(plus2['id'][i]), 'is_picat']            = True, True
            fp.loc[idx, 'picat_partner'],       fl.loc[int(plus2['id'][i]), 'picat_partner']       = int(plus2['id'][i]), idx
            fp.loc[idx, 'picat_dist'],          fl.loc[int(plus2['id'][i]), 'picat_dist']          = float(_dist), float(_dist)
            fp.loc[idx, 'picat_angle'],         fl.loc[int(plus2['id'][i]), 'picat_angle']         = float(angle1[i]), float(angle1[i])
            fp.loc[idx, 'picat_resname'],       fl.loc[int(plus2['id'][i]), 'picat_resname']       = str(_resname_r1), str(_resname_plus2)
            fp.loc[idx, 'picat_atomicnum'],     fl.loc[int(plus2['id'][i]), 'picat_atomicnum']     = int(protein.atom_dict[idx]['atomicnum']), int(_atom_plus2)            
            fp.loc[idx, 'picat_num_neighbors'], fl.loc[int(plus2['id'][i]), 'picat_num_neighbors'] = int(np.count_nonzero(protein.atom_dict[idx]['neighbors_id'])), int(_num_neighbors_plus2)
            fp.loc[idx, 'picat_is_ring'],       fl.loc[int(plus2['id'][i]), 'picat_is_ring']       = True, False
            fp.loc[idx, 'picat_is_cat'],        fl.loc[int(plus2['id'][i]), 'picat_is_cat']        = False, True
      
    cation_map = protein.atom_dict['isplus']
    r1, plus2 = close_contacts(ligand.ring_dict, protein.atom_dict[cation_map], cutoff, x_column='centroid')
    angle1 = angle_2v(r1['vector'], plus2['coords'] - r1['centroid'])

    for i in range(len(r1)):
        _dist = math.dist(r1['centroid'][i], plus2['coords'][i])
        _resname_r1, _resname_plus2 = r1['resname'][i], plus2['resname'][i]
        _resnum_r1, _resnum_plus2 = r1['resnum'][i], plus2['resnum'][i]
        _atom_plus2 = plus2['atomicnum'][i]
        _neighbors_plus2 = plus2['neighbors_id'][i]
        _num_neighbors_plus2 = np.count_nonzero(_neighbors_plus2)

        if _int == True:
            if _resname_r1 == '':
                _resname_r1 = 'LIG'
            elif _resname_plus2 == '':
                _resname_plus2 = 'LIG'
        else:
            pass
            
        _atoms_array = np.where(ligand.atom_dict['resnum'] == _resnum_r1)[0]
        for j in range(len(_atoms_array)):
            idx = int(_atoms_array[j])
            
            fl.loc[idx, 'is_picat'],            fp.loc[int(plus2['id'][i]), 'is_picat']            = True, True
            fl.loc[idx, 'picat_partner'],       fp.loc[int(plus2['id'][i]), 'picat_partner']       = int(plus2['id'][i]), idx
            fl.loc[idx, 'picat_dist'],          fp.loc[int(plus2['id'][i]), 'picat_dist']          = float(_dist), float(_dist)
            fl.loc[idx, 'picat_angle'],         fp.loc[int(plus2['id'][i]), 'picat_angle']         = float(angle1[i]), float(angle1[i])
            fl.loc[idx, 'picat_resname'],       fp.loc[int(plus2['id'][i]), 'picat_resname']       = str(_resname_r1), str(_resname_plus2)
            fl.loc[idx, 'picat_atomicnum'],     fp.loc[int(plus2['id'][i]), 'picat_atomicnum']     = int(ligand.atom_dict[idx]['atomicnum']), int(_atom_plus2)            
            fl.loc[idx, 'picat_num_neighbors'], fp.loc[int(plus2['id'][i]), 'picat_num_neighbors'] = int(np.count_nonzero(ligand.atom_dict[idx]['neighbors_id'])), int(_num_neighbors_plus2)
            fl.loc[idx, 'picat_is_ring'],       fp.loc[int(plus2['id'][i]), 'picat_is_ring']       = True, False
            fl.loc[idx, 'picat_is_cat'],        fp.loc[int(plus2['id'][i]), 'picat_is_cat']        = False, True

    return fp, fl



def acceptor_metal_oddt(mol1, mol2, fp, fl, _int=True, cutoff=settings['acceptor_metal_dist_cut'], tolerance=30):
    """Returns pairs of acceptor-metal atoms, which meet metal coordination criteria
    Note: This function is directional (mol1 holds acceptors, mol2 holds metals)

    Parameters
    ----------
    mol1, mol2 : oddt.toolkit.Molecule object
        Molecules to compute acceptor and metal pairs

    cutoff : float, (default=4)
        Distance cutoff for A-M pairs

    tolerance : int, (default=30)
        Range (+/- tolerance) from perfect direction defined by atoms hybridization
        in metal coordination are considered as strict.

    Returns
    -------
    a, d : atom_dict-type numpy array
        Aligned arrays of atoms forming metal coordination,
        firstly acceptors, secondly metals.

    strict : numpy array, dtype=bool
        Boolean array align with atom pairs, informing whether atoms
        form 'strict' metal coordination (pass all angular cutoffs).
        If false, only distance cutoff is met, therefore the interaction
        is 'crude'.
    """
    a, m = close_contacts(mol1.atom_dict[mol1.atom_dict['isacceptor']],
                          mol2.atom_dict[mol2.atom_dict['ismetal']],
                          cutoff)
    # skip empty values
    if len(a) > 0 and len(m) > 0:
        angle1 = angle(m['coords'][:, np.newaxis, :],
                       a['coords'][:, np.newaxis, :],
                       a['neighbors'])
    else:
        return fp, fl
        
    if _int == True:
        for i in range(len(a)):
            _dist = math.dist(a['coords'][i], m['coords'][i])
            _charge_a, _charge_m= a['charge'][i], m['charge'][i]
            _resname_a, _resname_m = a['resname'][i], m['resname'][i]
            _atom_a, _atom_m = a['atomicnum'][i], m['atomicnum'][i]
            _neighbors_a, _neighbors_m = a['neighbors_id'][i], m['neighbors_id'][i]
            _num_neighbors_a, _num_neighbors_m = np.count_nonzero(_neighbors_a), np.count_nonzero(_neighbors_m)
            _is_aromatic_a, _is_aromatic_m = a['isaromatic'][i], m['isaromatic'][i]
            

            fp.loc[int(a['id'][i]), 'is_acmetal'],            fl.loc[int(m['id'][i]), 'is_acmetal']            = True, True
            fp.loc[int(a['id'][i]), 'acmetal_partner'],       fl.loc[int(m['id'][i]), 'acmetal_partner']       = int(m['id'][i]), int(a['id'][i])
            fp.loc[int(a['id'][i]), 'acmetal_dist'],          fl.loc[int(m['id'][i]), 'acmetal_dist']          = float(_dist), float(_dist)
            fp.loc[int(a['id'][i]), 'acmetal_angle'],         fl.loc[int(m['id'][i]), 'acmetal_angle']         = float(angle1[i][0]), float(angle1[i][0])
            fp.loc[int(a['id'][i]), 'acmetal_charge'],        fl.loc[int(m['id'][i]), 'acmetal_charge']        = float(_charge_a), float(_charge_m)
            fp.loc[int(a['id'][i]), 'acmetal_atomicnum'],     fl.loc[int(m['id'][i]), 'acmetal_atomicnum']     = int(_atom_a), int(_atom_m)
            fp.loc[int(a['id'][i]), 'acmetal_resname'],       fl.loc[int(m['id'][i]), 'acmetal_resname']       = str(_resname_a), 'METAL'
            fp.loc[int(a['id'][i]), 'acmetal_num_neighbors'], fl.loc[int(m['id'][i]), 'acmetal_num_neighbors'] = int(_num_neighbors_a), 0
            fp.loc[int(a['id'][i]), 'acmetal_is_aromatic'],   fl.loc[int(m['id'][i]), 'acmetal_is_aromatic']   = int(_is_aromatic_a), int(_is_aromatic_m)

    return fp, fl
        



def pimetal_oddt(mol1, mol2, fp, fl, _int=True, cutoff=settings['pimetal_dist_cut'], tolerance=30):
    """Returns pairs of ring-metal atoms, which meet pi-metal criteria

    Parameters
    ----------
    mol1, mol2 : oddt.toolkit.Molecule object
        Molecules to compute ring-metal pairs

    cutoff : float, (default=5)
        Distance cutoff for Pi-metal pairs

    tolerance : int, (default=30)
        Range (+/- tolerance) from perfect direction (perpendicular)
        in which pi-metal are considered as strict.

    Returns
    -------
    r1 : ring_dict-type numpy array
        Aligned rings forming pi-metal

    m : atom_dict-type numpy array
        Aligned metals forming pi-metal

    strict_parallel : numpy array, dtype=bool
        Boolean array align with ring-metal pairs, informing whether
        they form 'strict' pi-metal. If false, only distance cutoff is met,
        therefore the interaction is 'crude'.

    """
    r1, m = close_contacts(mol1.ring_dict,
                           mol2.atom_dict[mol2.atom_dict['ismetal']],
                           cutoff,
                           x_column='centroid')
    
    if len(r1) > 0 and len(m) > 0:
        angle1 = angle_2v(r1['vector'], m['coords'] - r1['centroid'])
        strict = (angle1 > 180 - tolerance) | (angle1 < tolerance)
    else:
        return fp, fl


    if _int == True:
        for i in range(len(r1)):
            _dist = math.dist(r1['coords'][i], m['coords'][i])
            _charge_m = m['charge'][i]
            _resname_r1, _resname_m = r1['resname'][i], m['resname'][i]
            _atom_m = m['atomicnum'][i]

            _resnum_r1 = int(r1['resnum'][i])
            if _resname_r1 == '':
                _atoms_array = np.where(mol2.atom_dict['resnum'] == _resnum_r1)[0]
            else:
                _atoms_array = np.where(mol1.atom_dict['resnum'] == _resnum_r1)[0]


            for j in range(len(_atoms_array)):
                idx = int(_atoms_array[j])
                              
                fp.loc[idx, 'is_pimetal'],            fl.loc[m['id'][i], 'is_pimetal']            = True, True
                fp.loc[idx, 'pimetal_partner'],       fl.loc[m['id'][i], 'pimetal_partner']       = int(m['id'][i]), idx
                fp.loc[idx, 'pimetal_dist'],          fl.loc[m['id'][i], 'pimetal_dist']          = float(_dist), float(_dist)
                fp.loc[idx, 'pimetal_angle'],         fl.loc[m['id'][i], 'pimetal_angle']         = float(angle1[i][0]), float(angle1[i][0])
                fp.loc[idx, 'pimetal_charge'],        fl.loc[m['id'][i], 'pimetal_charge']        = float(mol1.atom_dict[idx]['charge']), float(_charge_m)
                fp.loc[idx, 'pimetal_atomicnum'],     fl.loc[m['id'][i], 'pimetal_atomicnum']     = int(mol1.atom_dict[idx]['atomicnum']), int(_atom_m)
                fp.loc[idx, 'pimetal_resname'],       fl.loc[m['id'][i], 'pimetal_resname']       = str(_resname_r1), 'METAL'

    return fp, fl



#######################################################################################
####################################### Parsing #######################################
#######################################################################################

def fingerprint(protein, ligand, _int=True, settings=settings):
    """
    Parameters
    ----------
    protein, ligand : list, with len(protein) == len(ligand) == 2
        First entry is the Molecule class object based on RDKit.
        Second entry is the oddt.toolkit.Molecule object used exclusively to 
            compute pi_stacking only using ODDT library.
    
    Returns
    -------
    fp : pandas DataFrame, shape = [n rows x 18 columns]
        A table which contains all the computed data, e.g., distance, angles, etc.    
    """
    
    max_len, lig_len = len(protein.atom_dict), len(ligand.atom_dict)
    
    # construct an empty DataFrame for ligand
    fl = pd.DataFrame(
        columns=["is_hbond", "hbond_partner", "hbond_dist", "hbond_angle", "hbond_charge", "hbond_atomicnum", "hbond_resname", "hbond_num_neighbors", "hbond_is_aromatic", "hbond_is_acceptor", "hbond_is_donor", 
                 "is_xbond", "xbond_partner", "xbond_dist", "xbond_angle", "xbond_charge", "xbond_atomicnum", "xbond_resname", "xbond_num_neighbors", "xbond_is_aromatic", "xbond_is_acceptor", "xbond_is_donor",
                 "is_hphob", "hphob_partner", "hphob_dist", "hphob_charge", "hphob_atomicnum", "hphob_resname", "hphob_num_neighbors", "hphob_is_aromatic", 
                 "is_sbridge", "sbridge_partner", "sbridge_dist", "sbridge_charge",  "sbridge_atomicnum", "sbridge_resname", "sbridge_num_neighbors", "sbridge_is_aromatic", "sbridge_is_pos", "sbridge_is_neg",
                 "is_pistack", "pistack_partner", "pistack_dist", "pistack_angle", "pistack_resname", "pistack_atomicnum", "pistack_num_neighbors",
                 "is_picat", "picat_partner", "picat_dist", "picat_angle", "picat_resname", "picat_num_neighbors", "picat_atomicnum", "picat_is_ring", "picat_is_cat",
                 "is_acmetal", "acmetal_partner", "acmetal_dist", "acmetal_angle", "acmetal_charge", "acmetal_atomicnum", "acmetal_resname", "acmetal_num_neighbors", "acmetal_is_aromatic",
                 "is_pimetal", "pimetal_partner", "pimetal_dist", "pimetal_angle", "pimetal_charge", "pimetal_atomicnum", "pimetal_resname"], index=range(lig_len))
    fl.fillna(0)

    # construct an empty DataFrame for protein
    fp = pd.DataFrame(
        columns=["is_hbond", "hbond_partner", "hbond_dist", "hbond_angle", "hbond_charge", "hbond_atomicnum", "hbond_resname", "hbond_num_neighbors", "hbond_is_aromatic", "hbond_is_acceptor", "hbond_is_donor", 
                 "is_xbond", "xbond_partner", "xbond_dist", "xbond_angle", "xbond_charge", "xbond_atomicnum", "xbond_resname", "xbond_num_neighbors", "xbond_is_aromatic", "xbond_is_acceptor", "xbond_is_donor",
                 "is_hphob", "hphob_partner", "hphob_dist", "hphob_charge", "hphob_atomicnum", "hphob_resname", "hphob_num_neighbors", "hphob_is_aromatic", 
                 "is_sbridge", "sbridge_partner", "sbridge_dist", "sbridge_charge",  "sbridge_atomicnum", "sbridge_resname", "sbridge_num_neighbors", "sbridge_is_aromatic", "sbridge_is_pos", "sbridge_is_neg",
                 "is_pistack", "pistack_partner", "pistack_dist", "pistack_angle", "pistack_resname", "pistack_atomicnum", "pistack_num_neighbors",
                 "is_picat", "picat_partner", "picat_dist", "picat_angle", "picat_resname", "picat_num_neighbors", "picat_atomicnum", "picat_is_ring", "picat_is_cat",
                 "is_acmetal", "acmetal_partner", "acmetal_dist", "acmetal_angle", "acmetal_charge", "acmetal_atomicnum", "acmetal_resname", "acmetal_num_neighbors", "acmetal_is_aromatic",
                 "is_pimetal", "pimetal_partner", "pimetal_dist", "pimetal_angle", "pimetal_charge", "pimetal_atomicnum", "pimetal_resname"], index=range(max_len))
    fp.fillna(0)
    
    fp, fl = hbonds_oddt(protein, ligand, fp, fl, cutoff=settings['hbond_dist_cut'], _int=True)
    fp, fl = hphob_oddt(protein, ligand, fp, fl, cutoff=settings['hphob_dist_cut'], _int=True)
    fp, fl = sbridge_oddt(protein, ligand, fp, fl, cutoff=settings['sbridge_dist_cut'], _int=True)
    fp, fl = pistack_oddt(protein, ligand, fp, fl, cutoff=settings['pistack_dist_cut'], _int=True)
    fp, fl = pication_oddt(protein, ligand, fp, fl, cutoff=settings['pication_dist_cut'], _int=True)
    fp, fl = xbonds_oddt(protein, ligand, fp, fl, cutoff=settings['xbond_dist_cut'], _int=True)
    fp, fl = acceptor_metal_oddt(protein, ligand, fp, fl, cutoff=settings['acceptor_metal_dist_cut'], _int=True)
    fp, fl = pimetal_oddt(protein, ligand, fp, fl, cutoff=settings['pimetal_dist_cut'], _int=True)

    return fp.dropna(axis=0, how="all"), fl.dropna(axis=0, how="all")
    


